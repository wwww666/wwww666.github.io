---
layout:     post
title:     	寻找数组的中心下标
subtitle:    寻找数组的中心下标
date:       2021-04-15
author:     wzk
header-img: img/home-bg-o.jpg
catalog: true
tags:
    - 算法
    - java
---

## 前言

每日学习总结记录


>关键词：leetcode,java,算法

### 寻找数组的中心下标
给你一个整数数组 nums，请编写一个能够返回数组 “中心下标” 的方法。  
数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。  
如果数组不存在中心下标，返回 -1 。如果数组有多个中心下标，应该返回最靠近左边的那一个。    
官方链接：[leetcode-寻找数组的中心下标](https://leetcode-cn.com/problems/find-pivot-index/)  
示例：
```
输入：nums = [1, 7, 3, 6, 5, 6]
输出：3
解释：
中心下标是 3 。
左侧数之和 (1 + 7 + 3 = 11)，
右侧数之和 (5 + 6 = 11) ，二者相等。

输入：nums = [1, 2, 3]
输出：-1
解释：
数组中不存在满足此条件的中心下标。

输入：nums = [2, 1, -1]
输出：0
解释：
中心下标是 0 。
下标 0 左侧不存在元素，视作和为 0 ；
右侧数之和为 1 + (-1) = 0 ，二者相等。
```
这道题可以用经典的前缀和方法来解决。我们要找到一个点，使得左右两边的数之和相等，这个点是不包含在左右两边
计算之内的。那么我们可以首先计算出整个数组的和，然后再从头遍历，计算数组0下标到当前下标的和，判断总和减去当前和
是不是与剩下的数相等，如果相等，那么当前点就是中心点，直接返回该下标。不相等就继续循环判断，没有结果就返回-1.  
直接看代码：
```
public int pivotIndex(int[] nums) {
        int presum=0;  
        for(int num:nums){ #计算整个数组的和
            presum+=num;
        }
        int leftsum=0;  #定义一个左边数组的和
        for(int i=0;i<nums.length;i++){

            if(leftsum==presum-nums[i]-leftsum){。#判断到当前点的所有左边的数之和是否等于剩下的数组的和
                return i;   #如果相等，直接返回当前下标
            }
            leftsum+=nums[i]; 到当前点数组累加
        }
        return -1;

    }
```
如果你有什么疑问或其他解法，都可以联系我一起讨论。共同进步！如果本篇文章或者本博客对你有帮助，请给我点一个star吧！




 

